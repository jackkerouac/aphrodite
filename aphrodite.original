#!/usr/bin/env python3
# simplified_aphrodite.py

import os
import sys
import argparse
import requests
from PIL import Image

# Import only the essential functions
from aphrodite_helpers.check_jellyfin_connection import load_settings
from aphrodite_helpers.badge_components.badge_settings import load_badge_settings
from aphrodite_helpers.badge_components.badge_generator import create_badge

def display_banner():
    """Display the Aphrodite banner."""
    BANNER = r"""
              _                   _ _ _       
             | |                 | (_) |      
   __ _ _ __ | |__  _ __ ___   __| |_| |_ ___ 
  / _` | '_ \| '_ \| '__/ _ \ / _` | | __/ _ \
 | (_| | |_) | | | | | | (_) | (_| | | ||  __/
  \__,_| .__/|_| |_|_|  \___/ \__,_|_|\__\___|
       | |                                    
       |_|                                    

                    v0.2.0       
    """
    print(BANNER)

def get_media_info(jellyfin_url, api_key, user_id, item_id):
    """Get media information for a Jellyfin item."""
    print(f"üìÑ Getting media info for item: {item_id}")
    
    # Get basic item information
    info_endpoint = f"{jellyfin_url}/Users/{user_id}/Items/{item_id}"
    playback_endpoint = f"{jellyfin_url}/Items/{item_id}/PlaybackInfo?UserId={user_id}"
    headers = {"X-Emby-Token": api_key}
    
    try:
        # Get item info
        info_response = requests.get(info_endpoint, headers=headers)
        info_response.raise_for_status()
        item_info = info_response.json()
        
        # Get media streams info
        playback_response = requests.get(playback_endpoint, headers=headers)
        playback_response.raise_for_status()
        playback_info = playback_response.json()
        
        # Extract audio codec information
        media_sources = playback_info.get('MediaSources', [])
        audio_codecs = []
        
        if media_sources:
            media_source = media_sources[0]
            media_streams = media_source.get('MediaStreams', [])
            
            for stream in media_streams:
                if stream.get('Type', '').lower() == 'audio':
                    codec = stream.get('Codec', 'Unknown')
                    channels = stream.get('Channels', 0)
                    audio_codecs.append({
                        'codec': codec,
                        'channels': channels,
                        'display_name': f"{codec.upper()} {channels}.0" if channels else codec.upper()
                    })
        
        # Use the first audio codec as primary
        primary_audio_codec = audio_codecs[0]['display_name'] if audio_codecs else "UNKNOWN"
        
        print(f"‚úÖ Found audio codec: {primary_audio_codec} for {item_info.get('Name', 'Unknown')}")
        
        return {
            'id': item_id,
            'name': item_info.get('Name', 'Unknown'),
            'type': item_info.get('Type', 'Unknown'),
            'audio_codec': primary_audio_codec
        }
        
    except requests.RequestException as e:
        print(f"‚ùå Error fetching media info: {e}")
        return None

def download_poster(jellyfin_url, api_key, item_id, output_dir="posters/original", resize_width=1000):
    """Download a poster for a Jellyfin item and resize to standard width."""
    print(f"üñºÔ∏è Downloading poster for item: {item_id}")
    
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # Set up poster URL and file path
    poster_url = f"{jellyfin_url}/Items/{item_id}/Images/Primary"
    file_path = os.path.join(output_dir, f"{item_id}.jpg")
    
    # Download the poster
    headers = {"X-Emby-Token": api_key}
    
    try:
        response = requests.get(poster_url, headers=headers, stream=True)
        response.raise_for_status()
        
        with open(file_path, "wb") as f:
            for chunk in response.iter_content(1024):
                f.write(chunk)
        
        # Resize the poster to standard width if needed
        if resize_width > 0:
            try:
                img = Image.open(file_path)
                # Only resize if the image is larger than the target width
                if img.width > resize_width:
                    # Calculate height to maintain aspect ratio
                    ratio = img.height / img.width
                    new_height = int(resize_width * ratio)
                    # Resize and save
                    img = img.resize((resize_width, new_height), Image.LANCZOS)
                    img.save(file_path, "JPEG", quality=95)
                    print(f"  Resized poster to {resize_width}x{new_height}")
            except Exception as e:
                print(f"  Warning: Could not resize poster: {e}")
        
        print(f"‚úÖ Poster saved to: {file_path}")
        return file_path
    
    except requests.RequestException as e:
        print(f"‚ùå Error downloading poster: {e}")
        return None

def apply_badge_to_poster(poster_path, badge, output_dir="posters/modified"):
    """Apply a badge to a poster image."""
    print(f"üîÑ Applying badge to poster: {os.path.basename(poster_path)}")
    
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # Get output file path
    output_path = os.path.join(output_dir, os.path.basename(poster_path))
    
    try:
        # Open the poster image
        poster = Image.open(poster_path).convert("RGBA")
        
        # Calculate badge position (top-right corner with 30px padding)
        position = (poster.width - badge.width - 30, 30)
        
        # Create a new image for the combined result
        result = Image.new("RGBA", poster.size, (0, 0, 0, 0))
        
        # Paste the poster
        result.paste(poster, (0, 0))
        
        # Paste the badge using its alpha channel as mask
        result.paste(badge, position, badge)
        
        # Convert to RGB for saving as JPEG
        result = result.convert("RGB")
        
        # Save the result
        result.save(output_path, "JPEG", quality=95)
        
        print(f"‚úÖ Badge applied successfully, saved to: {output_path}")
        return output_path
    
    except Exception as e:
        print(f"‚ùå Error applying badge: {e}")
        return None

def process_item(jellyfin_url, api_key, user_id, item_id, use_image_badge=True):
    """Process a single item: get info, download poster, apply badge."""
    print(f"\nüìã Processing item: {item_id}")
    
    # Step 1: Get media info
    media_info = get_media_info(jellyfin_url, api_key, user_id, item_id)
    if not media_info:
        print(f"‚ùå Failed to retrieve media information for item {item_id}")
        return False
    
    # Step 2: Download poster
    poster_path = download_poster(jellyfin_url, api_key, item_id)
    if not poster_path:
        print(f"‚ùå Failed to download poster for item {item_id}")
        return False
    
    # Step 3: Create badge
    badge_settings = load_badge_settings()
    if not badge_settings:
        print(f"‚ùå Failed to load badge settings")
        return False
    
    badge = create_badge(badge_settings, media_info['audio_codec'], use_image=use_image_badge)
    if not badge:
        print(f"‚ùå Failed to create badge")
        return False
    
    # Step 4: Apply badge to poster
    output_path = apply_badge_to_poster(poster_path, badge)
    if not output_path:
        print(f"‚ùå Failed to apply badge to poster")
        return False
    
    print(f"\n‚úÖ Successfully processed item: {media_info['name']} with audio codec: {media_info['audio_codec']}")
    return True

def process_library(jellyfin_url, api_key, user_id, library_id, limit=None, use_image_badge=True):
    """Process all items in a library."""
    print(f"\nüìö Processing items from library: {library_id}")
    
    # Get library items endpoint
    endpoint = f"{jellyfin_url}/Users/{user_id}/Items?ParentId={library_id}&Recursive=true"
    headers = {"X-Emby-Token": api_key}
    
    try:
        response = requests.get(endpoint, headers=headers)
        response.raise_for_status()
        items = response.json().get('Items', [])
        
        if not items:
            print("‚ö†Ô∏è No items found in library.")
            return False
        
        print(f"Found {len(items)} items in library")
        
        # Limit the number of items if specified
        if limit and limit > 0:
            items = items[:limit]
            print(f"Processing the first {limit} items")
        
        # Process each item
        success_count = 0
        for i, item in enumerate(items, 1):
            item_id = item.get('Id')
            item_name = item.get('Name', 'Unknown')
            
            print(f"\n[{i}/{len(items)}] Processing: {item_name} (ID: {item_id})")
            
            if process_item(jellyfin_url, api_key, user_id, item_id, use_image_badge):
                success_count += 1
        
        print(f"\n‚úÖ Successfully processed {success_count} of {len(items)} items")
        return success_count > 0
        
    except requests.RequestException as e:
        print(f"‚ùå Error fetching library items: {e}")
        return False

def check_jellyfin_connection(jellyfin_url, api_key, user_id):
    """Check connection to Jellyfin server."""
    print(f"\nüì° Connecting to Jellyfin at: {jellyfin_url}")
    
    headers = {"X-Emby-Token": api_key}
    endpoint = f"{jellyfin_url}/System/Info"
    
    try:
        response = requests.get(endpoint, headers=headers)
        response.raise_for_status()
        
        info = response.json()
        print(f"‚úÖ Connected to Jellyfin server: {info.get('ServerName', 'Unknown')}")
        print(f"   Version: {info.get('Version', 'Unknown')}")
        
        # Get libraries
        libraries_endpoint = f"{jellyfin_url}/Users/{user_id}/Views"
        libraries_response = requests.get(libraries_endpoint, headers=headers)
        libraries_response.raise_for_status()
        
        libraries = libraries_response.json().get('Items', [])
        
        if libraries:
            print("\nüìö Available libraries:")
            for lib in libraries:
                lib_name = lib.get('Name', 'Unnamed')
                lib_id = lib.get('Id', 'Unknown')
                
                # Get item count
                count_endpoint = f"{jellyfin_url}/Users/{user_id}/Items/Count?ParentId={lib_id}"
                count_response = requests.get(count_endpoint, headers=headers)
                
                if count_response.status_code == 200:
                    count = count_response.json().get('Items', 0)
                else:
                    count = "Unknown"
                
                print(f"  - {lib_name} (ID: {lib_id}): {count} items")
        
        return True
        
    except requests.RequestException as e:
        print(f"‚ùå Error connecting to Jellyfin: {e}")
        return False

def main():
    """Main entry point."""
    display_banner()
    
    # Set up argument parser
    parser = argparse.ArgumentParser(description="Aphrodite - Jellyfin Poster Processing System")
    
    # Subparsers for different commands
    subparsers = parser.add_subparsers(dest="command", help="Command")
    
    # Check command
    check_parser = subparsers.add_parser("check", help="Check system settings and Jellyfin connection")
    
    # Process item command
    item_parser = subparsers.add_parser("item", help="Process a single item")
    item_parser.add_argument("item_id", help="Jellyfin item ID")
    item_parser.add_argument("--text", action="store_true", help="Use text-based badges instead of images")
    
    # Process library command
    library_parser = subparsers.add_parser("library", help="Process all items in a library")
    library_parser.add_argument("library_id", help="Jellyfin library ID")
    library_parser.add_argument("--limit", type=int, help="Limit the number of items to process")
    library_parser.add_argument("--text", action="store_true", help="Use text-based badges instead of images")
    
    # Parse arguments
    args = parser.parse_args()
    
    # Load settings
    settings = load_settings()
    if not settings:
        print("‚ùå Failed to load settings")
        return 1
    
    jellyfin_settings = settings['api_keys']['Jellyfin'][0]
    url = jellyfin_settings['url']
    api_key = jellyfin_settings['api_key']
    user_id = jellyfin_settings['user_id']
    
    # Process command
    if args.command == "check":
        success = check_jellyfin_connection(url, api_key, user_id)
        return 0 if success else 1
    
    elif args.command == "item":
        success = process_item(url, api_key, user_id, args.item_id, not args.text)
        return 0 if success else 1
    
    elif args.command == "library":
        success = process_library(url, api_key, user_id, args.library_id, args.limit, not args.text)
        return 0 if success else 1
    
    else:
        parser.print_help()
        return 0

if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\nüõë Operation cancelled by user")
        sys.exit(130)
    except Exception as e:
        print(f"\n‚ùå Unexpected error: {str(e)}")
        sys.exit(1)
